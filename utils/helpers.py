from datetime import datetime, timezone
import re

# from itertools import permutations

from logs.mylogging import logger

from settings.settings import MAX_SEARCHES_AMOUNT
from utils.ai_validate_call_params import ai_validate_params_input


# --------------------------------------------------USER ADDS A SEARCH---------------------------------
def search_formatted_to_dict(search_formatted) -> dict:
    return {
        i.split(":")[0].strip(): i.split(":")[1].strip()
        for i in search_formatted.strip("\n").split("\n")
    }


def params_to_template(params: dict) -> str:
    return "\n".join(f"{k}: {v}" for k, v in params.items())


def extract_digit_from_command(command: str) -> int:
    match = re.search(r"\d+", command)
    if match:
        return int(match.group())
    else:
        return 0


def next_available_search_num(storage) -> int:
    for i in range(1, MAX_SEARCHES_AMOUNT + 1):
        if str(i) not in storage:
            return i
    return 0


async def params_input_validator(text: str) -> dict:
    no_header_lines_list = text.split("\n")[1:]

    try:
        diction = search_formatted_to_dict("\n".join(no_header_lines_list))
        code, message = await ai_validate_params_input(params_to_template(diction))
        if code == 1:
            return diction  # returns a dictionary if all is ok

        logger.info(f"Error parsing {text} with dict_validator: {message}")
        return message

    except:
        logger.info(f"Error parsing {text} with dict_validator; couldn't create a dict")
        return "Error parsing your message. :(\n\n/template"


# --------------------------------------------------OTHER HELPERS----------------------------------
def escape_markdown_v2(text):
    if type(text) != str:
        text = str(text)
    characters = [
        "_",
        "*",
        "[",
        "]",
        "(",
        ")",
        "~",
        "`",
        ">",
        "#",
        "+",
        "-",
        "=",
        "|",
        "{",
        "}",
        ".",
        "!",
    ]
    for char in characters:
        text = text.replace(char, "\\" + char)
    return text


def time_until(date_time_str, flag="minutes"):
    # Parsing the date-time string to a datetime object
    if not date_time_str:
        return None
    flags = {"minutes": 60, "hours": 3600, "days": 86400}
    if date_time_str.endswith("Z"):
        event_datetime = datetime.fromisoformat(date_time_str.replace("Z", "+00:00"))

        # Getting the current datetime in UTC
        current_datetime = datetime.now(timezone.utc)

        # Calculating the difference in hours
        time_difference = (event_datetime - current_datetime).total_seconds() / flags[
            flag
        ]

        # If the difference is positive (i.e., the event is in the future), return the difference
        if time_difference > 0:
            return int(time_difference)
        else:
            return 0
    else:
        # raise ValueError
        logger.info(
            "helpers.time_until: The date-time string does not appear to be in UTC. Please provide a UTC date-time string."
        )


def textify_auction(end_date, bidprice, link):
    result = "â—ï¸_{} {}_\n\nðŸ’°*{}*\n\n{}"
    flags = ["days", "hours", "minutes"]
    for flag in flags:
        time = time_until(end_date, flag=flag)
        if time >= 1:
            if time == 1:
                flag = flag[:-1]
            return result.format(time, flag, bidprice, link)
        elif flag == "minutes":
            return result.format(time, flag, bidprice, link)


def textify_search_item(d: dict):
    item_id = d.get("legacyItemId")
    link = f"https://www.ebay.com/itm/{item_id}"
    formatted_link = f"[{escape_markdown_v2(link)}]({escape_markdown_v2(link)})"

    bidprice = d.get("currentBidPrice", {}).get("value")
    if bidprice:
        bidprice = escape_markdown_v2(bidprice)
        end_date = d.get("itemEndDate")
        return textify_auction(end_date, bidprice, formatted_link)

    price = d.get("price", {}).get("value")
    if price:
        return f"ðŸ’°*{escape_markdown_v2(price)}*\n\n{formatted_link}"
    logger.info(f"helpers.textify: Item {d} returned None")


# before the AI...

# def combine_strings(strings_list):
#     """
#     All possible ways to 'join' a list
#     """
#     combined_strings = []

#     for r in range(1, len(strings_list) + 1):
#         for subset in permutations(strings_list, r):
#             combined_strings.append(",".join(subset))

#     return "|".join(combined_strings)


# def parse_text(text):
#     # res generated by combine string
#     patterns = {
#         "search": r"search:.{1,50}",
#         "price_low": r"price_low:[0-9]+(?:\.[0-9][0-9])?|999999999",
#         "price_up": r"price_up:[0-9]+(?:\.[0-9][0-9])?|1000000000",
#         "sorts": r"sorts:(?:bestMatch|newlyListed|endingSoonest|bestMatch,newlyListed|bestMatch,endingSoonest|newlyListed,bestMatch|newlyListed,endingSoonest|endingSoonest,bestMatch|endingSoonest,newlyListed|bestMatch,newlyListed,endingSoonest|bestMatch,endingSoonest,newlyListed|newlyListed,bestMatch,endingSoonest|newlyListed,endingSoonest,bestMatch|endingSoonest,bestMatch,newlyListed|endingSoonest,newlyListed,bestMatch)",
#         "buying_options": r"buying_options:(?:AUCTION|FIXED_PRICE|BEST_OFFER|AUCTION,FIXED_PRICE|AUCTION,BEST_OFFER|FIXED_PRICE,AUCTION|FIXED_PRICE,BEST_OFFER|BEST_OFFER,AUCTION|BEST_OFFER,FIXED_PRICE|AUCTION,FIXED_PRICE,BEST_OFFER|AUCTION,BEST_OFFER,FIXED_PRICE|FIXED_PRICE,AUCTION,BEST_OFFER|FIXED_PRICE,BEST_OFFER,AUCTION|BEST_OFFER,AUCTION,FIXED_PRICE|BEST_OFFER,FIXED_PRICE,AUCTION)",
#         "limit": r"limit:[1-7]",
#         "conditions": r"conditions:(?:USED|UNSPECIFIED|NEW|USED,UNSPECIFIED|USED,NEW|UNSPECIFIED,USED|UNSPECIFIED,NEW|NEW,USED|NEW,UNSPECIFIED|USED,UNSPECIFIED,NEW|USED,NEW,UNSPECIFIED|UNSPECIFIED,USED,NEW|UNSPECIFIED,NEW,USED|NEW,USED,UNSPECIFIED|NEW,UNSPECIFIED,USED)",
#     }
#     lines = text.split("\n")
#     lines = [line for line in lines if line]  # Removing empty lines

#     keys_found = []
#     ok_lines = []
#     problematic_lines = []
#     for line in lines:
#         is_ok = False
#         for key, pattern in patterns.items():
#             if re.fullmatch(pattern, line):
#                 keys_found.append(key)
#                 ok_lines.append(line)
#                 is_ok = True
#                 break
#         if not is_ok:
#             problematic_lines.append(line)
#     if "search" not in keys_found:
#         return 400, "please specify your search!"
#     if problematic_lines:
#         l = "\n".join(problematic_lines)
#         return 400, f"these lines are wrong:\n{l}"
#     return 200, "\n".join(ok_lines)
